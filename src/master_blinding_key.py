import wallycore as wally
from os import urandom, path, remove
from rpc import RPCHost
import re

WIF_VERSION_MAINNET = int('80', 16)
WIF_VERSION_TESTNET = int('ef', 16)
WIF_FLAG_COMPRESSED = int('00', 16)
BIP32_VER_TEST_PRIVATE = int("04358394", 16)
BIP32_FLAG_KEY_PRIVATE = int('00', 16)

dir = path.expandvars('$PWD')
dump_file1 = dir + 'test_dump'
dump_file2 = dir + 'test_dump2'
dump_file3 = dir + 'test_dump3'

# First erase any existing wallet dump
if path.isfile(dump_file1) is True:
    print("erasing previous test_dump")
    remove(dump_file1)

if path.isfile(dump_file2) is True:
    print("erasing previous test_dump2")
    remove(dump_file2)

if path.isfile(dump_file3) is True:
    print("erasing previous test_dump3")
    remove(dump_file3)

# This code is meant for demonstration only, please don't use this with real money

def check_wallet_identical(file1, file2):
    masterkey1 = ""
    masterkey2 = ""
    # First check that the extended master privkey is the same
    f = open(file1)
    for line in f:
        line = re.findall("tprv.*", line)
        if line:
            masterkey1 = line
            break
    f = open(file2)
    for line in f:
        line = re.findall("tprv.*", line)
        if line:
            masterkey2 = line
            break
    print("1st wallet masterkey is\n", masterkey1, \
        "\n2nd wallet masterkey is\n", masterkey2)
    assert masterkey1 == masterkey2
    print("They are the same!\n")
    # Find a way to compare the addresses being generated, it's not very clear in the dump file

# Let's try using a privatekey generated by another Elements wallet as a seed
host_1 = RPCHost("http://user1:password1@127.0.0.1:18884")
host_2 = RPCHost("http://user1:password1@127.0.0.1:18885")
host_3 = RPCHost("http://user1:password1@127.0.0.1:18891")

print(
    """
    \n
    ================================================
    First let's get a random private key from an Elements' wallet
    and use it to generate a new HD wallet in another node.
    ================================================
    \n
    """
)

print("get a new address from host1 and dump the privkey\n")
address = host_1.call('getnewaddress')
wif_privkey = host_1.call('dumpprivkey', address)
print("here is the privkey from host1", wif_privkey, "\n")

print("Now we import it inside host2 wallet and generate a new masterkey\n")
host_2.call('sethdseed', True, wif_privkey)
host_2.call('dumpwallet', dump_file2)

# Let's check the privkey labeled 'hdseed=1' in the dump, it should be the same
f = open(dump_file2)

for line in f:
    line = re.findall(".*" + wif_privkey + ".*", line)
    if line:
        print("Here is the privkey labeled 'hdseed=1' from host2 wallet dumpfile")
        print(line)
        print("It's the same.")
        break

# Now let's try with a random secret
print(
    """
    \n
    ================================================
    Now let's use urandom to get 32 bytes
    and generate a new HD wallet.
    ================================================
    \n
    """
)

entropy = bytearray(urandom(32))

wif_entropy = wally.wif_from_bytes(entropy, WIF_VERSION_TESTNET, WIF_FLAG_COMPRESSED)
print("here is the WIF encoding of entropy", wif_entropy, "\n")

print("This time import it inside host1 wallet and generate a new masterkey\n")
host_1.call('sethdseed', True, wif_entropy)
host_1.call('dumpwallet', dump_file1)

# Let's check the privkey labeled 'hdseed=1' in the dump, it should be the same
f = open(dump_file1)

for line in f:
    line = re.findall(".*" + wif_entropy + ".*", line)
    if line:
        print("Here is the privkey labeled 'hdseed=1' from host2 wallet dumpfile")
        print(line)
        print("It's the same, everything's alright.")
        break

# Let's use the same keys in the wallet of a third node and see if we have the same addresses

print(
    """
    \n
    ================================================
    We have generated 2 HD wallet
    let's import both seed in a third one
    and check that the masterkey is the same.
    ================================================
    \n
    """
)

print("importing ", wif_privkey, " as seed")
host_3.call('sethdseed', True, wif_privkey)
host_3.call('dumpwallet', dump_file3)
check_wallet_identical(dump_file2, dump_file3)

remove(dump_file3)

print("importing ", wif_entropy, " as seed")
host_3.call('sethdseed', True, wif_entropy)
host_3.call('dumpwallet', dump_file3)
check_wallet_identical(dump_file1, dump_file3)

# We can't import a master blinding key directly in
# a wallet, so we will use the keys generated from
# the 1st to blind the transaction in the 2nd

print(
    """
    \n
    ================================================
    Since we can't directly import a master blinding key
    inside a wallet, let's use the addresses generated by host1
    to blind the transactions of host2
    ================================================
    \n
    """
)

blinding_address = host_1.call('getnewaddress')
blinding_pubkey = host_1.call('getaddressinfo', blinding_address)['pubkey']
blinding_privkey = b""
blinding_privkey = wally.wif_to_bytes(
    host_1.call('dumpprivkey', blinding_address),
    WIF_VERSION_TESTNET,
    WIF_FLAG_COMPRESSED
    )
print("The blinding key pair is ", blinding_pubkey, blinding_privkey)

unconfidential_address = host_2.call('getnewaddress')
print("Blinding host2 unconfidential address:", unconfidential_address)
confidential_address = host_2.call('createblindedaddress', unconfidential_address, blinding_pubkey)
print("Host2 confidential address:", confidential_address)
host_2.call('importblindingkey', confidential_address, blinding_privkey.hex())

# TODO: import a new, different seed in host3, send some sats from 1
# to 2, and prove that while 2 can see the amount, 3 can't

# Finally, let's create a master private key AND blinding key directly from the same seed in libwally
print(
    """
    \n
    ================================================
    Finally let's use Libwally's pseudo-random generator
    and BIP39 functions to generate a private masterkey
    and a blinding master key both from the same seed.
    ================================================
    \n
    """
)
_pass = "password".encode('utf-8')
salt = "NaCl".encode('utf-8')
root = bytearray('0'.encode('utf-8') * 32)

#wally.scrypt(_pass, salt, 1024, 8, 16, root)
root = wally.pbkdf2_hmac_sha256(_pass, salt, 0, 1024)

mnemonic = wally.bip39_mnemonic_from_bytes(None, root[0:32])

seed = bytearray(64)
wally.bip39_mnemonic_to_seed(mnemonic, "", seed)

print("from the seed", seed, "we generate:")

xpriv = wally.bip32_key_from_seed(seed, BIP32_VER_TEST_PRIVATE, 0)

print("the extended master privkey", wally.bip32_key_to_base58(xpriv, BIP32_FLAG_KEY_PRIVATE))

master_blinding_key = bytearray(64)
master_blinding_key = wally.asset_blinding_key_from_seed(root)

print("the master blinding key", master_blinding_key.hex())

# TODO:Derivate addresses with Libwally
# Blind it
